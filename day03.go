package main

import (
	"fmt"
	"math"
)

func init() {
	// Originally implemented at https://play.golang.org/p/J2vSvEPC82M
	codeForDay[3] = day3
}

type point struct {
	x int
	y int
}

func day3(example int) {
	// both start horizontal
	first := []int{1008, 428, -339, 16, 910, 221, 53, -546, -805, 376, -19, 708, 493, -489, -443, -567, 390, -771, 270, 737, 926, 181, -306, -456, -668, -79, -922, 433, -701, 472, 914, 903, -120, 199, -273, -206, -967, 711, 976, 976, 603, 8, -882, 980, 561, -697, -224, -620, -483, 193, 317, -588, -932, -990, 658, 998, -136, 759, 463, 890, -297, 648, 163, 250, 852, 699, 236, -254, -173, 720, -259, 632, -635, 426, 235, -699, 411, 650, -258, -997, -781, -209, -697, -306, -793, 657, -936, 317, 549, -798, -951, -80, 591, -480, 835, 292, -722, 987, -775, 173, 353, 404, -250, 652, -527, -282, -365, -657, -141, -301, 128, -590, -666, 478, -85, -822, -716, 68, 253, -186, 81, 741, -316, -615, -570, 407, -734, -345, -652, 362, -360, -791, 358, 190, -823, 274, -279, -998, -16, -644, -201, -469, 213, -487, -251, -395, 130, 902, -398, 201, -56, -850, 541, -661, 921, 647, 309, -550, -307, -68, 894, 653, -510, -375, 20, 86, 357, -120, -978, -200, -45, -247, 906, 334, -242, -466, 418, 548, 698, -158, 582, 469, -968, 736, 196, 437, 87, -722, 811, 625, -425, -675, -904, -331, 693, -491, 559, 540, -120, -975, 180, 224, 610, 260, -769, -486, 93, -300, -230, 181, -60, 910, -60, -554, -527, 37, 69, -649, 768, -835, -581, 932, -746, 170, -733, 40, -497, -957, 12, 686, 85, -461, 796, -142, 664, 787, 636, -621, 824, -421, 902, -686, -202, -839, 567, -129, -77, -917, -200, -106, 3, -546, -101, -762, 780, 334, -410, -190, 431, -828, -816, -529, 648, -449, -845, 49, 750, 864, -133, -822, 46, 475, -229, 929, -676, -793, 379, 71, -243, 640, -122, 183, 528, 22, 375, -928, 292, 796, 259, 325, -921, 489, -246, -153, -384, -684, -243, 65, -342, 662, 707}
	second := []int{-1008, -243, -602, -497, -395, 81, 589, 94, 640, -965, -397, -781, 464, 642, -130, -740, 938, -260, -106, -323, -626, 869, -495, 450, 640, -675, 602, -449, -542, 917, -244, 702, -644, -809, 902, 163, 118, 982, -867, -795, 546, 194, 397, -877, -354, -255, -477, 45, -707, -624, 806, 642, -926, -233, -800, 691, -990, -979, -431, 999, -423, -794, -238, 25, 986, 595, -167, 480, -555, 831, 496, 799, -897, -895, -993, -11, 486, 176, -90, 842, 499, 792, 787, 859, -100, 169, 170, -89, 297, -944, 362, -460, 147, 831, -45, 972, 582, -90, -934, 284, 555, 235, -138, 837, 965, 915, 928, 982, 157, -566, -953, 653, -629, 460, -335, -912, 355, -683, -710, -562, 392, -44, 707, -979, -749, -223, -776, -723, 735, -356, 49, 567, -563, -220, -868, 223, 448, -505, -411, 662, -188, -536, 55, 718, -108, -289, 435, 98, 775, 933, -127, -84, 253, -523, -2, -905, 266, 675, 758, -331, 122, 988, 215, -500, 89, 306, 833, 763, 570, -818, -985, 127, -87, -210, 355, -532, 870, 196, 695, 633, 170, -540, 506, 708, -663, 566, -633, 306, -452, 180, 463, -21, -220, -268, 608, 986, -493, -598, -957, -116, -454, -584, -405, 651, 352, 681, 807, 767, -988, 692, 474, 710, 607, 313, 711, 12, 371, -561, 72, 522, 270, 904, -49, 525, 562, 895, -232, -319, 902, -236, -601, -816, 836, 419, 610, 644, -733, 355, -836, 228, -895, -39, -44, -848, -965, 475, 56, 62, -458, 99, 236, -763, 912, 295, 515, 179, 20, -777, 511, -906, 903, 855, -507, -512, -63, -630, 442, 595, -701, 654, 238, -35, -31, -469, 6, -222, 132, -837, 921, 838, 986, -441, -950, -530, -397, 41, -81, -60, -245, -75, 620, -455, -937, -180, 215, -684, 724, 561, 479, -353, -501}

	m := make(map[point]int)

	p := point{0, 0}
	horiz := true
	steps := 0
	for _, val := range first {
		p, steps = fillMap(m, p, val, horiz, steps)
		horiz = !horiz
	}

	minManhat := math.MaxInt32

	p = point{0, 0}
	horiz = true
	for _, val := range second {
		var manhat int
		p, manhat = closestManhattan(m, p, val, horiz)
		horiz = !horiz
		if manhat < minManhat {
			minManhat = manhat
		}
	}

	fmt.Println("D3-P1:", minManhat)

	minDelay := math.MaxInt32

	p = point{0, 0}
	horiz = true
	steps = 0
	for _, val := range second {
		var delay int
		p, steps, delay = closestDelay(m, p, val, horiz, steps)
		horiz = !horiz
		if delay < minDelay {
			minDelay = delay
		}
	}

	fmt.Println("D3-P2:", minDelay)
}

func fillMap(m map[point]int, p point, val int, horiz bool, steps int) (point, int) {
	return iteratePoints(p, val, horiz, steps, func(pt point, st int) {
		if _, ok := m[pt]; !ok {
			m[pt] = st
		}
	})
}

func closestManhattan(m map[point]int, p point, val int, horiz bool) (point, int) {
	crossDist := math.MaxInt32
	p, _ = iteratePoints(p, val, horiz, 0, func(pt point, st int) {
		if _, ok := m[pt]; ok {
			dist := abs(pt.x) + abs(pt.y)
			if dist < crossDist {
				crossDist = dist
			}
		}
	})
	return p, crossDist
}

func closestDelay(m map[point]int, p point, val int, horiz bool, steps int) (point, int, int) {
	crossDist := math.MaxInt32
	p, steps = iteratePoints(p, val, horiz, steps, func(pt point, st2 int) {
		if st1, ok := m[pt]; ok {
			dist := st1 + st2
			if dist < crossDist {
				crossDist = dist
			}
		}
	})
	return p, steps, crossDist
}

func iteratePoints(p point, val int, horiz bool, steps int, f func(point, int)) (point, int) {
	incVal := 1
	if val < 0 {
		incVal = -1
		val = -val
	}

	for i := 1; i <= val; i++ {
		if horiz {
			p.x += incVal
		} else {
			p.y += incVal
		}
		steps++
		f(p, steps)
	}

	return p, steps
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}
